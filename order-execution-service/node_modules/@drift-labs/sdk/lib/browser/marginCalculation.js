"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MarginCalculation = exports.IsolatedMarginCalculation = exports.MarginContext = exports.MarketIdentifier = void 0;
const anchor_1 = require("@coral-xyz/anchor");
const numericConstants_1 = require("./constants/numericConstants");
const types_1 = require("./types");
class MarketIdentifier {
    constructor(marketType, marketIndex) {
        this.marketType = marketType;
        this.marketIndex = marketIndex;
    }
    static spot(marketIndex) {
        return new MarketIdentifier(types_1.MarketType.SPOT, marketIndex);
    }
    static perp(marketIndex) {
        return new MarketIdentifier(types_1.MarketType.PERP, marketIndex);
    }
    equals(other) {
        return (!!other &&
            this.marketType === other.marketType &&
            this.marketIndex === other.marketIndex);
    }
}
exports.MarketIdentifier = MarketIdentifier;
class MarginContext {
    constructor(marginType) {
        this.marginType = marginType;
        this.mode = { type: 'Standard' };
        this.strict = false;
        this.ignoreInvalidDepositOracles = false;
        this.marginBuffer = new anchor_1.BN(0);
    }
    static standard(marginType) {
        return new MarginContext(marginType);
    }
    static liquidation(marginBuffer) {
        const ctx = new MarginContext('Maintenance');
        ctx.mode = { type: 'Liquidation' };
        ctx.marginBuffer = marginBuffer !== null && marginBuffer !== void 0 ? marginBuffer : new anchor_1.BN(0);
        return ctx;
    }
    strictMode(strict) {
        this.strict = strict;
        return this;
    }
    ignoreInvalidDeposits(ignore) {
        this.ignoreInvalidDepositOracles = ignore;
        return this;
    }
    setMarginBuffer(buffer) {
        this.marginBuffer = buffer !== null && buffer !== void 0 ? buffer : new anchor_1.BN(0);
        return this;
    }
    setMarginRatioOverride(ratio) {
        this.marginRatioOverride = ratio;
        return this;
    }
}
exports.MarginContext = MarginContext;
class IsolatedMarginCalculation {
    constructor() {
        this.marginRequirement = new anchor_1.BN(0);
        this.totalCollateral = new anchor_1.BN(0);
        this.totalCollateralBuffer = new anchor_1.BN(0);
        this.marginRequirementPlusBuffer = new anchor_1.BN(0);
    }
    getTotalCollateralPlusBuffer() {
        return this.totalCollateral.add(this.totalCollateralBuffer);
    }
    meetsMarginRequirement() {
        return this.totalCollateral.gte(this.marginRequirement);
    }
    meetsMarginRequirementWithBuffer() {
        return this.getTotalCollateralPlusBuffer().gte(this.marginRequirementPlusBuffer);
    }
    marginShortage() {
        const shortage = this.marginRequirementPlusBuffer.sub(this.getTotalCollateralPlusBuffer());
        return shortage.isNeg() ? new anchor_1.BN(0) : shortage;
    }
}
exports.IsolatedMarginCalculation = IsolatedMarginCalculation;
class MarginCalculation {
    constructor(context) {
        this.context = context;
        this.totalCollateral = new anchor_1.BN(0);
        this.totalCollateralBuffer = new anchor_1.BN(0);
        this.marginRequirement = new anchor_1.BN(0);
        this.marginRequirementPlusBuffer = new anchor_1.BN(0);
        this.isolatedMarginCalculations = new Map();
        this.numSpotLiabilities = 0;
        this.numPerpLiabilities = 0;
        this.allDepositOraclesValid = true;
        this.allLiabilityOraclesValid = true;
        this.withPerpIsolatedLiability = false;
        this.withSpotIsolatedLiability = false;
        this.totalSpotLiabilityValue = new anchor_1.BN(0);
        this.totalPerpLiabilityValue = new anchor_1.BN(0);
        this.trackedMarketMarginRequirement = new anchor_1.BN(0);
        this.fuelDeposits = 0;
        this.fuelBorrows = 0;
        this.fuelPositions = 0;
    }
    addCrossMarginTotalCollateral(delta) {
        this.totalCollateral = this.totalCollateral.add(delta);
        if (this.context.marginBuffer.gt(new anchor_1.BN(0)) && delta.isNeg()) {
            this.totalCollateralBuffer = this.totalCollateralBuffer.add(delta.mul(this.context.marginBuffer).div(numericConstants_1.MARGIN_PRECISION));
        }
    }
    addCrossMarginRequirement(marginRequirement, liabilityValue) {
        this.marginRequirement = this.marginRequirement.add(marginRequirement);
        if (this.context.marginBuffer.gt(new anchor_1.BN(0))) {
            this.marginRequirementPlusBuffer = this.marginRequirementPlusBuffer.add(marginRequirement.add(liabilityValue.mul(this.context.marginBuffer).div(numericConstants_1.MARGIN_PRECISION)));
        }
    }
    addIsolatedMarginCalculation(marketIndex, depositValue, pnl, liabilityValue, marginRequirement) {
        const totalCollateral = depositValue.add(pnl);
        const totalCollateralBuffer = this.context.marginBuffer.gt(new anchor_1.BN(0)) && pnl.isNeg()
            ? pnl.mul(this.context.marginBuffer).div(numericConstants_1.MARGIN_PRECISION)
            : new anchor_1.BN(0);
        const marginRequirementPlusBuffer = this.context.marginBuffer.gt(new anchor_1.BN(0))
            ? marginRequirement.add(liabilityValue.mul(this.context.marginBuffer).div(numericConstants_1.MARGIN_PRECISION))
            : new anchor_1.BN(0);
        const iso = new IsolatedMarginCalculation();
        iso.marginRequirement = marginRequirement;
        iso.totalCollateral = totalCollateral;
        iso.totalCollateralBuffer = totalCollateralBuffer;
        iso.marginRequirementPlusBuffer = marginRequirementPlusBuffer;
        this.isolatedMarginCalculations.set(marketIndex, iso);
    }
    addSpotLiability() {
        this.numSpotLiabilities += 1;
    }
    addPerpLiability() {
        this.numPerpLiabilities += 1;
    }
    addSpotLiabilityValue(spotLiabilityValue) {
        this.totalSpotLiabilityValue =
            this.totalSpotLiabilityValue.add(spotLiabilityValue);
    }
    addPerpLiabilityValue(perpLiabilityValue) {
        this.totalPerpLiabilityValue =
            this.totalPerpLiabilityValue.add(perpLiabilityValue);
    }
    updateAllDepositOraclesValid(valid) {
        this.allDepositOraclesValid = this.allDepositOraclesValid && valid;
    }
    updateAllLiabilityOraclesValid(valid) {
        this.allLiabilityOraclesValid = this.allLiabilityOraclesValid && valid;
    }
    updateWithSpotIsolatedLiability(isolated) {
        this.withSpotIsolatedLiability = this.withSpotIsolatedLiability || isolated;
    }
    updateWithPerpIsolatedLiability(isolated) {
        this.withPerpIsolatedLiability = this.withPerpIsolatedLiability || isolated;
    }
    validateNumSpotLiabilities() {
        if (this.numSpotLiabilities > 0 && this.marginRequirement.eq(new anchor_1.BN(0))) {
            throw new Error('InvalidMarginRatio: num_spot_liabilities>0 but margin_requirement=0');
        }
    }
    getNumOfLiabilities() {
        return this.numSpotLiabilities + this.numPerpLiabilities;
    }
    getCrossTotalCollateralPlusBuffer() {
        return this.totalCollateral.add(this.totalCollateralBuffer);
    }
    meetsCrossMarginRequirement() {
        return this.totalCollateral.gte(this.marginRequirement);
    }
    meetsCrossMarginRequirementWithBuffer() {
        return this.getCrossTotalCollateralPlusBuffer().gte(this.marginRequirementPlusBuffer);
    }
    meetsMarginRequirement() {
        if (!this.meetsCrossMarginRequirement())
            return false;
        for (const [, iso] of this.isolatedMarginCalculations) {
            if (!iso.meetsMarginRequirement())
                return false;
        }
        return true;
    }
    meetsMarginRequirementWithBuffer() {
        if (!this.meetsCrossMarginRequirementWithBuffer())
            return false;
        for (const [, iso] of this.isolatedMarginCalculations) {
            if (!iso.meetsMarginRequirementWithBuffer())
                return false;
        }
        return true;
    }
    getCrossFreeCollateral() {
        const free = this.totalCollateral.sub(this.marginRequirement);
        return free.isNeg() ? new anchor_1.BN(0) : free;
    }
    getIsolatedFreeCollateral(marketIndex) {
        const iso = this.isolatedMarginCalculations.get(marketIndex);
        if (!iso)
            throw new Error('InvalidMarginCalculation: missing isolated calc');
        const free = iso.totalCollateral.sub(iso.marginRequirement);
        return free.isNeg() ? new anchor_1.BN(0) : free;
    }
    getIsolatedMarginCalculation(marketIndex) {
        return this.isolatedMarginCalculations.get(marketIndex);
    }
    hasIsolatedMarginCalculation(marketIndex) {
        return this.isolatedMarginCalculations.has(marketIndex);
    }
}
exports.MarginCalculation = MarginCalculation;
