import { fetch } from './axios.js';
import { Keypair } from '@solana/web3.js';
import { Buffer } from 'buffer';
import { sign } from 'tweetnacl';
/**
 * Error class for x402-related errors
 */
export class X402Error extends Error {
    constructor(message) {
        super(message);
        this.name = 'X402Error';
        Object.setPrototypeOf(this, X402Error.prototype);
    }
}
/**
 * Executes an HTTP request based on an HttpTask and handles x402 Payment Required responses.
 *
 * If the response is 402 Payment Required:
 * - Parses the payment details from the response body
 * - Signs the payment details with the provided ed25519 keypair
 * - Returns the payment details and signature for further processing
 *
 * If the response is not 402:
 * - Returns the response data normally
 *
 * @param httpTask - The HttpTask configuration from an OracleJob
 * @param keypair - Ed25519 keypair for signing payment requests (Solana Keypair or Uint8Array secret key)
 * @returns Promise<X402Result> containing the response and optional payment details/signature
 *
 * @example
 * ```typescript
 * import { Keypair } from '@solana/web3.js';
 * import { handleX402Request } from '@switchboard-xyz/common/utils/x402';
 *
 * const httpTask = {
 *   url: 'https://api.x402-service.com/data',
 *   method: 1, // METHOD_GET
 *   headers: [{ key: 'Accept', value: 'application/json' }]
 * };
 *
 * const keypair = Keypair.generate();
 * const result = await handleX402Request(httpTask, keypair);
 *
 * if (result.is402) {
 *   console.log('Payment required:', result.paymentDetails);
 *   console.log('Signature:', result.signature);
 *
 *   // Now you can use the signature to make a payment
 *   // and retry the request with X-PAYMENT header
 * } else {
 *   console.log('Success:', result.data);
 * }
 * ```
 *
 * @example With raw secret key
 * ```typescript
 * const secretKey = new Uint8Array(64); // Your ed25519 secret key
 * const result = await handleX402Request(httpTask, secretKey);
 * ```
 */
export async function handleX402Request(httpTask, keypair) {
    var _a;
    // Validate httpTask
    if (!httpTask.url) {
        throw new X402Error('HttpTask must have a url');
    }
    // Convert method enum to HTTP method string
    const methodMap = {
        0: 'GET', // METHOD_UNKNOWN defaults to GET
        1: 'GET', // METHOD_GET
        2: 'POST', // METHOD_POST
    };
    const method = methodMap[(_a = httpTask.method) !== null && _a !== void 0 ? _a : 0] || 'GET';
    // Convert headers to fetch-compatible format
    const headers = {};
    if (httpTask.headers) {
        for (const header of httpTask.headers) {
            if (header.key && header.value) {
                headers[header.key] = header.value;
            }
        }
    }
    // Make the HTTP request
    const response = await fetch(httpTask.url, {
        method,
        headers,
        body: httpTask.body,
    });
    // Extract response headers
    const responseHeaders = {};
    response.headers.forEach((value, key) => {
        responseHeaders[key] = value;
    });
    // Get response text
    const text = await response.text();
    // Check if this is a 402 Payment Required response
    if (response.status === 402) {
        let paymentDetails;
        try {
            paymentDetails = JSON.parse(text);
        }
        catch (error) {
            throw new X402Error(`Failed to parse 402 response body as JSON: ${error instanceof Error ? error.message : String(error)}`);
        }
        // Validate payment details structure
        if (!paymentDetails.accepts || !Array.isArray(paymentDetails.accepts)) {
            throw new X402Error('Invalid 402 response: missing or invalid "accepts" array');
        }
        // Create canonical message to sign (JSON string of payment details)
        const messageToSign = JSON.stringify(paymentDetails, null, 0);
        const messageBytes = Buffer.from(messageToSign, 'utf-8');
        // Sign with ed25519 using tweetnacl
        let signature;
        if (keypair instanceof Keypair) {
            signature = sign.detached(messageBytes, keypair.secretKey);
        }
        else if (keypair instanceof Uint8Array) {
            // Assume it's a secret key
            signature = sign.detached(messageBytes, keypair);
        }
        else {
            throw new X402Error('Invalid keypair: must be Solana Keypair or Uint8Array secret key');
        }
        // Encode signature as base64
        const signatureBase64 = Buffer.from(signature).toString('base64');
        return {
            is402: true,
            status: response.status,
            paymentDetails,
            signature: signatureBase64,
            headers: responseHeaders,
            text,
        };
    }
    // Not a 402 response, return data normally
    let data;
    try {
        data = JSON.parse(text);
    }
    catch {
        // If not JSON, return text as-is
        data = text;
    }
    return {
        is402: false,
        status: response.status,
        data,
        headers: responseHeaders,
        text,
    };
}
/**
 * Creates an X-PAYMENT header value for retrying a request after receiving a 402 response.
 * This constructs the header value that should be used in the retry request.
 *
 * @param paymentDetails - The payment details from the 402 response
 * @param signature - The base64-encoded signature from handleX402Request
 * @param publicKey - The public key of the signer (base58 string or Uint8Array)
 * @returns The base64-encoded payment payload for the X-PAYMENT header
 *
 * @example
 * ```typescript
 * const result = await handleX402Request(httpTask, keypair);
 * if (result.is402) {
 *   const paymentHeader = createX402PaymentHeader(
 *     result.paymentDetails!,
 *     result.signature!,
 *     keypair.publicKey.toBase58()
 *   );
 *
 *   // Retry request with payment header
 *   const retryResponse = await fetch(httpTask.url!, {
 *     headers: {
 *       'X-PAYMENT': paymentHeader
 *     }
 *   });
 * }
 * ```
 */
export function createX402PaymentHeader(paymentDetails, signature, publicKey) {
    const payload = {
        payment_details: paymentDetails,
        signature,
        public_key: typeof publicKey === 'string'
            ? publicKey
            : Buffer.from(publicKey).toString('base64'),
    };
    return Buffer.from(JSON.stringify(payload)).toString('base64');
}
/**
 * Namespace export for compatibility with other utility modules
 */
export const X402Utils = {
    handleX402Request,
    createX402PaymentHeader,
};
